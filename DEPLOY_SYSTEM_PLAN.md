# План реализации системы автоматического деплоя

## Понимание задачи

### Часть 1: API Endpoint для деплоя на сервере (`/api/deploy`)
**Назначение:** Принимать запросы на обновление проекта на продакшн сервере

**Функционал:**
- Защита по ключу (DEPLOY_TOKEN из .env)
- Определение пути к PHP (env('PHP_PATH') или автоопределение, например: `php8.2`)
- Обновление проекта из git репозитория
- Установка зависимостей через composer
- Выполнение миграций базы данных
- Полный сброс кеша Laravel
- Отправка ответа о статусе выполнения (включая информацию о версии PHP)

**Важно:** 
- `npm run build` уже выполнен на локальной машине и файлы залиты в git, поэтому на сервере НЕ нужно выполнять npm build
- После `composer install` автоматически выполняются миграции базы данных через `{PHP_PATH} artisan migrate --force`
- `{PHP_PATH}` определяется автоматически или через переменную окружения `PHP_PATH` в .env (например: `php8.2`)

---

### Часть 2: Artisan команда `deploy` (локальная машина)
**Назначение:** Автоматизация процесса деплоя с локальной машины разработчика

**Функционал:**
1. Выполнить `npm run build` (сборка фронтенда)
2. Проверить наличие изменений в `public/build`
3. Добавить изменения в git, закоммитить и отправить в репозиторий
4. Отправить POST запрос на сервер для обновления
5. Отобразить статус обновления

---

## Детальный план реализации

### Этап 1: Подготовка .gitignore

**Задача:** Убрать исключение `public/build` из .gitignore, чтобы скомпилированные файлы попадали в git.

**Действия:**
- Удалить строку `/public/build` из `.gitignore`
- Добавить `public/build` в репозиторий
- Обновить `.gitignore` комментарием о том, что build файлы коммитятся

**Файл:** `.gitignore`

---

### Этап 2: API Endpoint `/api/deploy` (на сервере)

#### 2.1. Создание Middleware для проверки токена

**Файл:** `app/Http/Middleware/VerifyDeployToken.php`

**Функционал:**
- Проверять наличие заголовка `X-Deploy-Token` или параметра `token`
- Сравнивать с `DEPLOY_TOKEN` из `.env`
- Возвращать 401 при несовпадении

**Логика:**
```
1. Получить токен из запроса (header или параметр)
2. Сравнить с env('DEPLOY_TOKEN')
3. Если не совпадает → 401 Unauthorized
4. Если совпадает → пропустить дальше
```

---

#### 2.2. Создание контроллера DeployController

**Файл:** `app/Http/Controllers/Api/DeployController.php`

**Метод:** `deploy(Request $request)`

**Логика выполнения:**
```
1. Логирование начала деплоя
2. Сохранение текущего состояния (commit hash)
3. Git pull из репозитория (git pull origin main)
4. Composer install --no-dev --optimize-autoloader
5. Выполнение миграций базы данных:
   - {PHP_PATH} artisan migrate --force
   - Проверка успешности выполнения миграций
6. Очистка всех кешей Laravel:
   - {PHP_PATH} artisan config:clear
   - {PHP_PATH} artisan cache:clear
   - {PHP_PATH} artisan route:clear
   - {PHP_PATH} artisan view:clear
   - {PHP_PATH} artisan optimize:clear
7. Оптимизация (опционально):
   - {PHP_PATH} artisan config:cache
   - {PHP_PATH} artisan route:cache
   - {PHP_PATH} artisan view:cache

**Где {PHP_PATH} - путь к PHP:**
   - Определяется из env('PHP_PATH', 'php')
   - Или автоматически через обнаружение доступного PHP
   - Примеры: `php`, `php8.2`, `/usr/bin/php8.2`
8. Проверка статуса операций
9. Формирование ответа с результатами
```

**Обработка ошибок:**
- Try-catch для всех операций
- Логирование ошибок
- Возврат детального ответа об ошибках

**Особенности обработки миграций:**
- При ошибке миграции: логировать детали, но не останавливать весь процесс (зависит от критичности)
- Или: останавливать весь процесс при ошибке миграций (рекомендуется)
- Возвращать информацию о количестве выполненных миграций
- Возвращать ошибку с деталями SQL ошибки при неудаче

**Формат ответа:**
```json
{
  "success": true,
  "message": "Деплой успешно завершен",
  "data": {
    "php_version": "8.2.15",
    "php_path": "php8.2",
    "git_pull": "success",
    "composer_install": "success",
    "migrations": {
      "status": "success",
      "migrations_run": 5,
      "message": "Все миграции выполнены успешно"
    },
    "cache_cleared": true,
    "optimized": true,
    "commit_hash": "abc123...",
    "deployed_at": "2025-11-29 12:00:00"
  }
}
```

**При ошибке миграций:**
```json
{
  "success": false,
  "message": "Ошибка при выполнении миграций",
  "data": {
    "git_pull": "success",
    "composer_install": "success",
    "migrations": {
      "status": "error",
      "error": "SQLSTATE[42S01]: Base table or view already exists: 1050"
    }
  }
}
```

---

#### 2.3. Добавление маршрута

**Файл:** `routes/api.php`

**Маршрут:**
```php
Route::post('/deploy', [DeployController::class, 'deploy'])
    ->middleware('deploy.token');
```

**Защита:** Middleware `deploy.token` проверяет токен

---

### Этап 3: Artisan команда `deploy` (локальная машина)

**Файл:** `app/Console/Commands/Deploy.php`

#### 3.1. Структура команды

**Сигнатура:** `php artisan deploy [--message="Deploy message"]`

**Опции:**
- `--message`: Кастомное сообщение для коммита (по умолчанию автоматическое)

#### 3.2. Последовательность выполнения

**Шаг 1: Сборка фронтенда**
```
Выполнить: npm run build
Проверка: 
  - Успешность выполнения команды
  - Наличие изменений в public/build/
  - Если ошибка → остановка, сообщение об ошибке
```

**Шаг 2: Проверка git статуса**
```
Выполнить: git status
Проверка:
  - Есть ли изменения для коммита
  - Состояние репозитория
  - Текущая ветка (должна быть main или master)
```

**Шаг 3: Добавление изменений в git**
```
Выполнить:
  - git add .
  - git add public/build (убедиться что файлы добавлены)
Проверка:
  - Файлы из public/build действительно добавлены
```

**Шаг 4: Создание коммита**
```
Сообщение коммита:
  - Если указан --message: использовать его
  - Если нет: "Deploy: [дата и время]"
  
Выполнить: git commit -m "сообщение"
Проверка: Успешность коммита
```

**Шаг 5: Отправка в репозиторий**
```
Выполнить: git push origin main (или master)
Проверка:
  - Успешность push
  - Если ошибка → сообщение об ошибке, остановка
```

**Шаг 6: Отправка POST запроса на сервер**
```
URL: env('SERVER_URL') + '/api/deploy'
Метод: POST
Заголовки:
  - Content-Type: application/json
  - X-Deploy-Token: env('DEPLOY_TOKEN')
Тело запроса (опционально):
  {
    "commit_hash": "текущий commit hash",
    "deployed_by": "имя пользователя",
    "timestamp": "дата и время"
  }
```

**Шаг 7: Обработка ответа от сервера**
```
Проверка:
  - HTTP статус код
  - Парсинг JSON ответа
  - Вывод результата в консоль
  
Отображение:
  - Зеленый текст при успехе
  - Красный текст при ошибке
  - Детали операции (git pull, composer, cache и т.д.)
```

#### 3.3. Обработка ошибок

**Сценарии:**
1. Ошибка `npm run build` → остановка, сообщение
2. Нет изменений в git → предупреждение, запрос подтверждения
3. Ошибка git push → остановка, откат не выполняется
4. Ошибка HTTP запроса → вывод детальной ошибки
5. Ошибка на сервере (4xx, 5xx) → вывод ответа сервера

---

### Этап 4: Конфигурация .env

**Переменные для локальной машины (разработчика):**
```env
SERVER_URL=https://post-ads.ru
DEPLOY_TOKEN=123123123
```

**Переменные для сервера:**
```env
DEPLOY_TOKEN=123123123
PHP_PATH=php8.2
```

**Примечание:** 
- `PHP_PATH` - путь к исполняемому файлу PHP на сервере
- Если не указан, будет использован автоопределение (пробуются: `php8.2`, `php8.3`, `php8.1`, `php`)
- Примеры: `php`, `php8.2`, `php8.3`, `/usr/bin/php8.2`, `/usr/local/bin/php`
- Можно определить автоматически через проверку доступных версий
- В ответе деплоя будет указана версия и путь используемого PHP

**Пример .env.example для сервера:**
```env
# Deploy Configuration
DEPLOY_TOKEN=your-secure-deploy-token-here
PHP_PATH=php8.2  # Путь к PHP (опционально, автоопределение если не указан)
```

**Безопасность:**
- Токен должен быть сложным
- Хранить в .env (не коммитить в git)
- Использовать разные токены для dev и production (рекомендуется)

---

### Этап 5: Регистрация middleware

**Файл:** `bootstrap/app.php` или `app/Http/Kernel.php`

**Действие:**
- Зарегистрировать middleware `deploy.token`
- Или использовать inline middleware в роуте

---

### Этап 6: Дополнительные улучшения

#### 6.1. Логирование деплоев
- Создать таблицу `deployments` для истории деплоев
- Сохранять: дата, commit hash, статус, пользователь, ответ сервера

#### 6.2. Rollback функционал (опционально)
- Возможность отката к предыдущему коммиту
- Команда `php artisan deploy:rollback`

#### 6.3. Dry-run режим
- Опция `--dry-run` для команды deploy
- Показывает что будет сделано без выполнения

#### 6.4. Уведомления
- Email уведомления о деплое
- Telegram/Slack уведомления (опционально)

---

## Структура файлов

```
app/
├── Console/
│   └── Commands/
│       └── Deploy.php (новая команда)
├── Http/
│   ├── Controllers/
│   │   └── Api/
│   │       └── DeployController.php (новый контроллер)
│   └── Middleware/
│       └── VerifyDeployToken.php (новый middleware)
routes/
└── api.php (добавить маршрут)
.gitignore (убрать /public/build)
.env (добавить переменные)
.env.example (добавить переменные с примерами)
```

---

## Последовательность реализации

1. ✅ **Подготовка .gitignore** - убрать исключение public/build
2. ✅ **Создание middleware** - VerifyDeployToken
3. ✅ **Создание контроллера** - DeployController
4. ✅ **Добавление маршрута** - POST /api/deploy
5. ✅ **Регистрация middleware** - в bootstrap/app.php
6. ✅ **Создание Artisan команды** - Deploy
7. ✅ **Обновление .env.example** - добавить переменные
8. ✅ **Тестирование** - локально и на сервере

---

## Детали реализации каждой части

### DeployController::deploy()

**Методы:**
- `getPhpPath()` - определить путь к PHP (env('PHP_PATH') или автоопределение)
- `handleGitPull()` - выполнить git pull
- `handleComposerInstall()` - установить зависимости
- `runMigrations()` - выполнить миграции базы данных (используя определенный PHP)
- `clearAllCaches()` - очистить все кеши (используя определенный PHP)
- `optimizeApplication()` - оптимизировать приложение (используя определенный PHP)
- `getCurrentCommitHash()` - получить текущий commit hash
- `formatResponse()` - форматировать ответ
- `executeArtisanCommand()` - общий метод для выполнения artisan команд через определенный PHP

**Логика определения PHP пути:**
```
1. Проверить env('PHP_PATH')
2. Если не указан, попробовать:
   - php8.2
   - php8.3
   - php8.1
   - php (по умолчанию)
3. Проверить доступность через which или exec
4. Использовать первый найденный доступный вариант
5. Сохранить в лог какой PHP используется
```

**Безопасность:**
- Проверка что мы в правильной директории
- Валидация что git репозиторий существует
- Проверка прав на выполнение команд
- Валидация пути к PHP (предотвращение выполнения произвольных команд)

**Определение PHP на сервере:**
- Переменная окружения `PHP_PATH` в .env (например: `PHP_PATH=php8.2`)
- Автоматическое обнаружение через проверку доступных версий PHP
- Логирование используемой версии PHP в ответе деплоя

**Реализация метода getPhpPath():**
```php
protected function getPhpPath(): string
{
    // 1. Проверить явно указанный путь в .env
    $phpPath = env('PHP_PATH');
    if ($phpPath && $this->isPhpExecutable($phpPath)) {
        return $phpPath;
    }
    
    // 2. Попробовать автоматически найти PHP
    $possiblePaths = ['php8.2', 'php8.3', 'php8.1', 'php'];
    foreach ($possiblePaths as $path) {
        if ($this->isPhpExecutable($path)) {
            return $path;
        }
    }
    
    // 3. Fallback на 'php'
    return 'php';
}

protected function isPhpExecutable(string $path): bool
{
    // Проверка через which или exec
    $result = shell_exec("which {$path} 2>/dev/null");
    if ($result) {
        return true;
    }
    
    // Или проверка через exec
    exec("{$path} --version 2>&1", $output, $returnCode);
    return $returnCode === 0;
}
```

---

### Artisan Command Deploy

**Методы:**
- `handle()` - главный метод
- `buildFrontend()` - выполнить npm run build
- `checkGitStatus()` - проверить статус git
- `commitChanges()` - создать коммит
- `pushToRepository()` - отправить в git
- `sendDeployRequest()` - отправить POST запрос
- `formatOutput()` - форматировать вывод

**Вопросы пользователю:**
- Подтверждение перед push (если есть изменения)
- Подтверждение перед отправкой на сервер

**Прогресс-бар:**
- Отображать прогресс выполнения (опционально)

---

## Обработка edge cases

1. **Нет интернета:**
   - Git push может не выполниться → ошибка
   - POST запрос не отправится → ошибка

2. **Конфликты в git:**
   - На сервере могут быть локальные изменения
   - Нужна стратегия: `git pull --rebase` или `git reset --hard`

3. **Файлы блокированы:**
   - Composer может не обновиться если файлы используются
   - Кеш может не очиститься

4. **Права доступа:**
   - Проверка прав на запись в директории
   - Права на выполнение git/composer команд
   - Права на выполнение PHP команд

5. **Недостаточно места:**
   - Проверка свободного места перед деплоем

6. **PHP не найден или недоступен:**
   - Указанный PHP путь не существует
   - Нет прав на выполнение PHP
   - Fallback на стандартный `php` с предупреждением

---

## Тестирование

### Локальное тестирование:
1. Запуск `php artisan deploy` на локальной машине
2. Проверка что build создался
3. Проверка что изменения в git
4. Проверка что POST запрос отправляется

### Серверное тестирование:
1. Ручной POST запрос на `/api/deploy` с токеном
2. Проверка что определен правильный PHP путь (php_path в ответе)
3. Проверка что git pull выполнился
4. Проверка что composer install выполнился
5. Проверка что миграции выполнились
6. Проверка что кеши очистились
7. Проверка что версия PHP указана в ответе (php_version в ответе)

---

## Дополнительные соображения

### Безопасность:
- Токен должен быть достаточно сложным (минимум 32 символа)
- Использовать HTTPS для передачи токена
- Логировать все попытки деплоя
- Ограничить количество попыток (rate limiting)

### Производительность:
- Использовать `--no-dev` для composer на production
- Использовать `--optimize-autoloader` для composer
- Кешировать конфигурацию после деплоя

### Мониторинг:
- Логирование всех операций деплоя
- Отправка уведомлений об успехе/ошибке
- Сохранение истории деплоев в БД

---

## Пример использования

### Локальная машина (разработчик):
```bash
php artisan deploy
# или с кастомным сообщением:
php artisan deploy --message="Добавлен новый функционал"
```

### На сервере (автоматически):
После выполнения команды на локальной машине, автоматически отправляется POST запрос на сервер, который:
1. Получает запрос и проверяет токен
2. Определяет путь к PHP (env('PHP_PATH') или автоопределение, например: `php8.2`)
3. Обновляет проект из git (git pull)
4. Устанавливает зависимости (composer install)
5. Выполняет миграции базы данных ({PHP_PATH} artisan migrate --force)
6. Очищает все кеши Laravel ({PHP_PATH} artisan config:clear и т.д.)
7. Оптимизирует приложение ({PHP_PATH} artisan config:cache и т.д.)
8. Возвращает детальный ответ о статусе выполнения (включая версию PHP)

---

## Вопросы для уточнения

1. Какой метод git pull использовать на сервере?
   - `git pull origin main` (обычный)
   - `git pull --rebase origin main` (rebase)
   - `git fetch && git reset --hard origin/main` (жесткий reset)

2. ~~Нужно ли выполнять миграции при деплое?~~ ✅ **РЕШЕНО: Выполнять автоматически**
   - Миграции будут выполняться автоматически после composer install
   - Используется `php artisan migrate --force` (без интерактивного подтверждения)
   - Ошибки миграций будут логироваться и возвращаться в ответе

3. Нужно ли создавать backup перед деплоем?
   - Бэкап базы данных?
   - Бэкап файлов?

4. Как обрабатывать конфликты в git на сервере?
   - Откат?
   - Merge?
   - Reset hard?

5. ~~Какая версия PHP на сервере?~~ ✅ **УЧТЕНО: Определение PHP пути**
   - Поддержка разных путей к PHP: `php`, `php8.2`, `php8.3`
   - Переменная окружения `PHP_PATH` в .env
   - Автоматическое обнаружение доступной версии PHP
   - Логирование используемой версии в ответе

---

Этот план покрывает все аспекты реализации системы деплоя.

